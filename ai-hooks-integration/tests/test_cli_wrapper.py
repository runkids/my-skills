#!/usr/bin/env python3
"""Tests for CLI wrapper generation."""

import os
import sys
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "..", "scripts"))

from runtime.cli_wrapper import (
    find_original_binary,
    generate_wrapper,
    write_wrapper,
)


class TestGenerateWrapper(unittest.TestCase):
    """Test wrapper generation."""

    def test_bash_template(self):
        """Should generate bash wrapper with jq."""
        script = generate_wrapper(
            cli_name="gh",
            original_path="/usr/local/bin/gh",
            pre_hook="/path/to/hook",
            post_hook="/path/to/hook",
            template="bash",
        )
        self.assertIn("#!/bin/bash", script)
        self.assertIn('ORIGINAL="/usr/local/bin/gh"', script)
        self.assertIn('PRE_HOOK="/path/to/hook"', script)
        self.assertIn("jq", script)  # bash template uses jq

    def test_python_template(self):
        """Should generate python wrapper."""
        script = generate_wrapper(
            cli_name="kubectl",
            original_path="/usr/local/bin/kubectl",
            pre_hook="/path/to/hook",
            template="python",
        )
        self.assertIn("#!/usr/bin/env python3", script)
        self.assertIn('ORIGINAL = "/usr/local/bin/kubectl"', script)
        self.assertIn("import json", script)

    def test_minimal_template(self):
        """Should generate minimal wrapper without jq."""
        script = generate_wrapper(
            cli_name="aws",
            original_path="/usr/local/bin/aws",
            pre_hook="/path/to/hook",
            template="minimal",
        )
        self.assertIn("#!/bin/bash", script)
        self.assertIn("(minimal)", script)
        self.assertNotIn("jq", script)  # minimal doesn't use jq

    def test_empty_hooks(self):
        """Should handle empty hooks."""
        script = generate_wrapper(
            cli_name="ls",
            original_path="/bin/ls",
            pre_hook="",
            post_hook="",
            template="minimal",
        )
        self.assertIn('PRE_HOOK=""', script)
        self.assertIn('POST_HOOK=""', script)

    def test_custom_timeout(self):
        """Should respect custom timeout."""
        script = generate_wrapper(
            cli_name="gh",
            original_path="/usr/local/bin/gh",
            hook_timeout=10,
            template="bash",
        )
        self.assertIn("HOOK_TIMEOUT=10", script)

    def test_contains_generator_marker(self):
        """All templates should contain generator marker."""
        for template in ["bash", "python", "minimal"]:
            script = generate_wrapper(
                cli_name="test",
                original_path="/bin/test",
                template=template,
            )
            self.assertIn("Generated by ai-hooks-integration", script)


class TestWriteWrapper(unittest.TestCase):
    """Test wrapper file writing."""

    def test_creates_file(self):
        """Should create wrapper file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "test-cli"
            content = "#!/bin/bash\necho test"

            success = write_wrapper(path, content)

            self.assertTrue(success)
            self.assertTrue(path.exists())
            self.assertEqual(path.read_text(), content)

    def test_creates_parents(self):
        """Should create parent directories."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "nested" / "dir" / "cli"
            content = "#!/bin/bash"

            success = write_wrapper(path, content)

            self.assertTrue(success)
            self.assertTrue(path.exists())

    def test_makes_executable(self):
        """Should set executable permission."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "test-cli"
            content = "#!/bin/bash"

            write_wrapper(path, content)

            mode = path.stat().st_mode
            self.assertTrue(mode & 0o100)  # owner execute

    def test_respects_force_flag(self):
        """Should overwrite only with force flag."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "test-cli"
            path.write_text("original")

            # Without force - should fail
            success = write_wrapper(path, "new", force=False)
            self.assertFalse(success)
            self.assertEqual(path.read_text(), "original")

            # With force - should overwrite
            success = write_wrapper(path, "new", force=True)
            self.assertTrue(success)
            self.assertEqual(path.read_text(), "new")

    def test_dry_run(self):
        """Dry run should not create file."""
        with tempfile.TemporaryDirectory() as tmpdir:
            path = Path(tmpdir) / "test-cli"

            success = write_wrapper(path, "content", dry_run=True)

            self.assertTrue(success)
            self.assertFalse(path.exists())


class TestFindOriginalBinary(unittest.TestCase):
    """Test original binary detection."""

    def test_finds_common_binaries(self):
        """Should find common system binaries."""
        # ls should exist on all Unix systems
        result = find_original_binary("ls")
        self.assertIsNotNone(result)
        self.assertTrue(Path(result).exists())

    def test_returns_none_for_nonexistent(self):
        """Should return None for nonexistent binary."""
        result = find_original_binary("definitely-not-a-real-command-12345")
        self.assertIsNone(result)

    def test_excludes_directory(self):
        """Should exclude specified directory from search."""
        with tempfile.TemporaryDirectory() as tmpdir:
            # Create a fake binary in tmpdir
            fake = Path(tmpdir) / "ls"
            fake.write_text("fake")
            fake.chmod(0o755)

            # Add tmpdir to PATH temporarily
            old_path = os.environ.get("PATH", "")
            os.environ["PATH"] = f"{tmpdir}:{old_path}"

            try:
                # Should exclude tmpdir and find real ls
                result = find_original_binary("ls", exclude_dir=Path(tmpdir))
                if result:
                    self.assertNotEqual(Path(result).parent, Path(tmpdir))
            finally:
                os.environ["PATH"] = old_path


class TestWrapperIntegration(unittest.TestCase):
    """Integration tests for wrapper functionality."""

    def test_generated_bash_is_valid_syntax(self):
        """Generated bash should have valid syntax."""
        script = generate_wrapper(
            cli_name="test",
            original_path="/bin/test",
            pre_hook="/hook",
            template="bash",
        )

        with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
            f.write(script)
            f.flush()

            import subprocess

            result = subprocess.run(
                ["bash", "-n", f.name],
                capture_output=True,
            )
            os.unlink(f.name)

            self.assertEqual(result.returncode, 0, f"Syntax error: {result.stderr}")

    def test_generated_python_is_valid_syntax(self):
        """Generated python should have valid syntax."""
        script = generate_wrapper(
            cli_name="test",
            original_path="/bin/test",
            pre_hook="/hook",
            template="python",
        )

        with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
            f.write(script)
            f.flush()

            import subprocess

            result = subprocess.run(
                [sys.executable, "-m", "py_compile", f.name],
                capture_output=True,
            )
            os.unlink(f.name)

            self.assertEqual(result.returncode, 0, f"Syntax error: {result.stderr}")


if __name__ == "__main__":
    unittest.main()
