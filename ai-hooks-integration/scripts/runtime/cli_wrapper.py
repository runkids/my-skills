#!/usr/bin/env python3
"""CLI Wrapper Generator for tools without built-in hooks.

This module generates wrapper scripts that intercept CLI calls,
allowing pre/post hooks to be executed around the original command.

Use Case:
  For CLI tools that don't have a hooks API (like gh, aws, kubectl),
  a wrapper script placed in PATH (before the original) can intercept calls.

Example:
  # Original: /usr/local/bin/gh
  # Wrapper:  ~/.local/bin/gh (higher PATH priority)

  # When user runs "gh pr create", the wrapper:
  # 1. Runs pre-hook with args
  # 2. Calls original /usr/local/bin/gh pr create
  # 3. Runs post-hook with exit code and args
"""

from __future__ import annotations

import os
import stat
from pathlib import Path
from typing import Literal

# Bash wrapper template
BASH_TEMPLATE = '''\
#!/bin/bash
# CLI Wrapper for {cli_name}
# Generated by ai-hooks-integration
# Original: {original_path}

set -euo pipefail

ORIGINAL="{original_path}"
PRE_HOOK="{pre_hook}"
POST_HOOK="{post_hook}"
HOOK_TIMEOUT={hook_timeout}

# Run pre-hook (can block execution by returning non-zero)
if [[ -n "$PRE_HOOK" ]]; then
    # Send args as JSON to pre-hook stdin
    ARGS_JSON=$(printf '%s\\n' "$@" | jq -R -s -c 'split("\\n") | .[:-1]')
    PRE_INPUT=$(jq -n \\
        --arg cli "{cli_name}" \\
        --argjson args "$ARGS_JSON" \\
        --arg cwd "$PWD" \\
        '{{cli: $cli, args: $args, cwd: $cwd, phase: "pre"}}')

    PRE_RESULT=$(echo "$PRE_INPUT" | timeout "$HOOK_TIMEOUT" $PRE_HOOK 2>/dev/null) || true

    # Check if hook wants to block
    if [[ -n "$PRE_RESULT" ]]; then
        DECISION=$(echo "$PRE_RESULT" | jq -r '.decision // "allow"')
        if [[ "$DECISION" == "deny" ]]; then
            REASON=$(echo "$PRE_RESULT" | jq -r '.reason // "Blocked by pre-hook"')
            echo "Error: $REASON" >&2
            exit 1
        fi
    fi
fi

# Run original CLI
"$ORIGINAL" "$@"
EXIT_CODE=$?

# Run post-hook (informational, doesn't block)
if [[ -n "$POST_HOOK" ]]; then
    ARGS_JSON=$(printf '%s\\n' "$@" | jq -R -s -c 'split("\\n") | .[:-1]')
    POST_INPUT=$(jq -n \\
        --arg cli "{cli_name}" \\
        --argjson args "$ARGS_JSON" \\
        --arg cwd "$PWD" \\
        --argjson exit_code "$EXIT_CODE" \\
        '{{cli: $cli, args: $args, cwd: $cwd, exit_code: $exit_code, phase: "post"}}')

    echo "$POST_INPUT" | timeout "$HOOK_TIMEOUT" $POST_HOOK 2>/dev/null || true
fi

exit $EXIT_CODE
'''

# Python wrapper template (for systems without jq)
PYTHON_TEMPLATE = '''\
#!/usr/bin/env python3
# CLI Wrapper for {cli_name}
# Generated by ai-hooks-integration
# Original: {original_path}

import json
import os
import subprocess
import sys

ORIGINAL = "{original_path}"
PRE_HOOK = "{pre_hook}"
POST_HOOK = "{post_hook}"
HOOK_TIMEOUT = {hook_timeout}


def run_hook(hook_cmd: str, payload: dict) -> dict | None:
    """Run hook and return parsed JSON response."""
    if not hook_cmd:
        return None
    try:
        result = subprocess.run(
            hook_cmd.split(),
            input=json.dumps(payload),
            capture_output=True,
            text=True,
            timeout=HOOK_TIMEOUT,
        )
        if result.stdout.strip():
            return json.loads(result.stdout)
    except (subprocess.TimeoutExpired, json.JSONDecodeError, FileNotFoundError):
        pass
    return None


def main():
    args = sys.argv[1:]
    cwd = os.getcwd()

    # Pre-hook
    if PRE_HOOK:
        pre_payload = {{"cli": "{cli_name}", "args": args, "cwd": cwd, "phase": "pre"}}
        pre_result = run_hook(PRE_HOOK, pre_payload)
        if pre_result and pre_result.get("decision") == "deny":
            reason = pre_result.get("reason", "Blocked by pre-hook")
            print(f"Error: {{reason}}", file=sys.stderr)
            sys.exit(1)

    # Run original CLI
    result = subprocess.run([ORIGINAL] + args)
    exit_code = result.returncode

    # Post-hook
    if POST_HOOK:
        post_payload = {{
            "cli": "{cli_name}",
            "args": args,
            "cwd": cwd,
            "exit_code": exit_code,
            "phase": "post",
        }}
        run_hook(POST_HOOK, post_payload)

    sys.exit(exit_code)


if __name__ == "__main__":
    main()
'''

# Minimal shell wrapper (no jq dependency)
MINIMAL_TEMPLATE = '''\
#!/bin/bash
# CLI Wrapper for {cli_name} (minimal)
# Generated by ai-hooks-integration
# Original: {original_path}

ORIGINAL="{original_path}"
PRE_HOOK="{pre_hook}"
POST_HOOK="{post_hook}"

# Run pre-hook with args as positional parameters
if [[ -n "$PRE_HOOK" ]]; then
    $PRE_HOOK --cli {cli_name} --phase pre -- "$@"
    if [[ $? -ne 0 ]]; then
        echo "Error: Blocked by pre-hook" >&2
        exit 1
    fi
fi

# Run original CLI
"$ORIGINAL" "$@"
EXIT_CODE=$?

# Run post-hook
if [[ -n "$POST_HOOK" ]]; then
    $POST_HOOK --cli {cli_name} --phase post --exit-code $EXIT_CODE -- "$@" || true
fi

exit $EXIT_CODE
'''


def generate_wrapper(
    cli_name: str,
    original_path: str,
    pre_hook: str = "",
    post_hook: str = "",
    hook_timeout: int = 5,
    template: Literal["bash", "python", "minimal"] = "bash",
) -> str:
    """Generate a CLI wrapper script.

    Args:
        cli_name: Name of the CLI being wrapped (e.g., "gh", "kubectl").
        original_path: Absolute path to the original CLI binary.
        pre_hook: Command to run before the CLI (receives JSON on stdin).
        post_hook: Command to run after the CLI (receives JSON on stdin).
        hook_timeout: Timeout in seconds for hook execution.
        template: Template type - "bash" (requires jq), "python", or "minimal".

    Returns:
        Generated wrapper script content.

    Example:
        >>> script = generate_wrapper(
        ...     cli_name="gh",
        ...     original_path="/usr/local/bin/gh",
        ...     pre_hook="/path/to/hook",
        ...     post_hook="/path/to/hook",
        ... )
        >>> print(script)
    """
    templates = {
        "bash": BASH_TEMPLATE,
        "python": PYTHON_TEMPLATE,
        "minimal": MINIMAL_TEMPLATE,
    }

    template_content = templates[template]

    return template_content.format(
        cli_name=cli_name,
        original_path=original_path,
        pre_hook=pre_hook,
        post_hook=post_hook,
        hook_timeout=hook_timeout,
    )


def write_wrapper(
    output_path: Path,
    content: str,
    force: bool = False,
    dry_run: bool = False,
) -> bool:
    """Write wrapper script to file with executable permissions.

    Args:
        output_path: Where to write the wrapper.
        content: Wrapper script content.
        force: Overwrite existing file.
        dry_run: Print actions without writing.

    Returns:
        True if successful, False otherwise.
    """
    if output_path.exists() and not force:
        return False

    if dry_run:
        print(f"[dry-run] write {output_path}")
        print(content)
        return True

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(content)

    # Make executable
    current_mode = output_path.stat().st_mode
    output_path.chmod(current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    return True


def find_original_binary(cli_name: str, exclude_dir: Path | None = None) -> str | None:
    """Find the original binary path, excluding wrapper directory.

    Args:
        cli_name: Name of the CLI to find.
        exclude_dir: Directory to exclude from search (where wrapper lives).

    Returns:
        Absolute path to original binary, or None if not found.
    """
    import shutil

    # Get all paths
    path_dirs = os.environ.get("PATH", "").split(os.pathsep)

    for path_dir in path_dirs:
        path_dir = Path(path_dir)

        # Skip excluded directory
        if exclude_dir and path_dir.resolve() == exclude_dir.resolve():
            continue

        candidate = path_dir / cli_name
        if candidate.exists() and os.access(candidate, os.X_OK):
            return str(candidate.resolve())

    # Fallback to which/where
    result = shutil.which(cli_name)
    if result:
        result_path = Path(result).resolve()
        if exclude_dir and result_path.parent.resolve() == exclude_dir.resolve():
            return None
        return str(result_path)

    return None


if __name__ == "__main__":
    # Demo
    import argparse

    ap = argparse.ArgumentParser(description="Generate CLI wrapper script")
    ap.add_argument("cli_name", help="Name of CLI to wrap")
    ap.add_argument("--original", help="Path to original binary (auto-detected if omitted)")
    ap.add_argument("--pre-hook", default="", help="Pre-execution hook command")
    ap.add_argument("--post-hook", default="", help="Post-execution hook command")
    ap.add_argument("--timeout", type=int, default=5, help="Hook timeout in seconds")
    ap.add_argument(
        "--template",
        choices=["bash", "python", "minimal"],
        default="bash",
        help="Wrapper template type",
    )
    args = ap.parse_args()

    original = args.original or find_original_binary(args.cli_name)
    if not original:
        print(f"Error: Cannot find original binary for '{args.cli_name}'", file=sys.stderr)
        sys.exit(1)

    script = generate_wrapper(
        cli_name=args.cli_name,
        original_path=original,
        pre_hook=args.pre_hook,
        post_hook=args.post_hook,
        hook_timeout=args.timeout,
        template=args.template,
    )
    print(script)
